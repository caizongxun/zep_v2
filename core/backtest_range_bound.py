"""\n區間震盪策略回測引擎\n"""\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Dict, List\nfrom core.range_bound_strategy import RangeBoundStrategy\n\n\nclass BacktestRangeBound:\n    def __init__(\n        self,\n        initial_capital: float = 10000.0,\n        leverage: float = 1.0,\n        fee_rate: float = 0.0006,  # 0.06% taker fee\n    ):\n        self.initial_capital = initial_capital\n        self.leverage = leverage\n        self.fee_rate = fee_rate\n        \n    def run(\n        self,\n        df: pd.DataFrame,\n        strategy: RangeBoundStrategy\n    ) -> Dict:\n        """\n        執行回測\n        \n        Args:\n            df: K線數據 (must have OHLCV)\n            strategy: RangeBoundStrategy instance\n            \n        Returns:\n            回測結果字典\n        """\n        # 添加指標\n        df = strategy.add_indicators(df)\n        \n        # 初始化\n        balance = self.initial_capital\n        position = None  # {'type': 'long'/'short', 'entry': price, 'size': qty, 'sl': price, 'tp': price}\n        \n        trades = []\n        equity_curve = []\n        \n        # 逐根K線迭代\n        for i in range(50, len(df)):  # 跳過前50根以確保指標充分\n            current_bar = df.iloc[:i+1]  # 只使用到當前K線的數據\n            row = current_bar.iloc[-1]\n            \n            current_price = row['close']\n            current_time = row['open_time'] if 'open_time' in row.index else i\n            \n            # 計算當前權益\n            current_equity = balance\n            if position:\n                if position['type'] == 'long':\n                    pnl = (current_price - position['entry']) * position['size']\n                else:\n                    pnl = (position['entry'] - current_price) * position['size']\n                current_equity += pnl\n            \n            equity_curve.append({\n                'time': current_time,\n                'equity': current_equity,\n                'balance': balance\n            })\n            \n            # === 檢查出場條件 ===\n            if position:\n                # 1. 止損\n                hit_sl = (position['type'] == 'long' and row['low'] <= position['sl']) or \\\n                         (position['type'] == 'short' and row['high'] >= position['sl'])\n                \n                # 2. 止盈\n                hit_tp = (position['type'] == 'long' and row['high'] >= position['tp']) or \\\n                         (position['type'] == 'short' and row['low'] <= position['tp'])\n                \n                # 3. 策略出場 (回到BB中軌)\n                exit_signal = strategy.check_exit(current_bar, position['type'])\n                \n                exit_price = None\n                exit_reason = None\n                \n                if hit_sl:\n                    exit_price = position['sl']\n                    exit_reason = 'Stop Loss'\n                elif hit_tp:\n                    exit_price = position['tp']\n                    exit_reason = 'Take Profit'\n                elif exit_signal['exit']:\n                    exit_price = current_price\n                    exit_reason = exit_signal['reason']\n                \n                # 執行出場\n                if exit_price:\n                    # 計算損益\n                    if position['type'] == 'long':\n                        pnl = (exit_price - position['entry']) * position['size']\n                    else:\n                        pnl = (position['entry'] - exit_price) * position['size']\n                    \n                    # 扣除手續費\n                    fee = exit_price * position['size'] * self.fee_rate\n                    pnl -= fee\n                    \n                    balance += pnl\n                    \n                    trades.append({\n                        'time': current_time,\n                        'type': f\"CLOSE_{position['type'].upper()}\",\n                        'price': exit_price,\n                        'pnl': pnl,\n                        'balance': balance,\n                        'reason': exit_reason\n                    })\n                    \n                    position = None\n                    continue\n            \n            # === 檢查進場條件 ===\n            if position is None:\n                signal = strategy.generate_signal(current_bar)\n                \n                if signal['signal'] in ['buy', 'sell']:\n                    entry_price = current_price\n                    \n                    # 位置大小計算\n                    position_value = balance * self.leverage\n                    position_size = position_value / entry_price\n                    \n                    # 扣除開倉手續費\n                    open_fee = entry_price * position_size * self.fee_rate\n                    balance -= open_fee\n                    \n                    position = {\n                        'type': 'long' if signal['signal'] == 'buy' else 'short',\n                        'entry': entry_price,\n                        'size': position_size,\n                        'sl': signal['stop_loss'],\n                        'tp': signal['take_profit']\n                    }\n                    \n                    trades.append({\n                        'time': current_time,\n                        'type': f\"OPEN_{position['type'].upper()}\",\n                        'price': entry_price,\n                        'sl': signal['stop_loss'],\n                        'tp': signal['take_profit'],\n                        'balance': balance,\n                        'reason': signal['reason']\n                    })\n        \n        # 強制平倉 (如果還有持倉)\n        if position:\n            final_price = df.iloc[-1]['close']\n            if position['type'] == 'long':\n                pnl = (final_price - position['entry']) * position['size']\n            else:\n                pnl = (position['entry'] - final_price) * position['size']\n            \n            fee = final_price * position['size'] * self.fee_rate\n            pnl -= fee\n            balance += pnl\n            \n            trades.append({\n                'time': df.iloc[-1]['open_time'] if 'open_time' in df.columns else len(df)-1,\n                'type': 'FORCE_CLOSE',\n                'price': final_price,\n                'pnl': pnl,\n                'balance': balance,\n                'reason': 'End of backtest'\n            })\n        \n        # 計算統計\n        trades_df = pd.DataFrame(trades)\n        equity_df = pd.DataFrame(equity_curve)\n        \n        stats = self._calculate_stats(trades_df, equity_df)\n        \n        return {\n            'trades': trades_df,\n            'equity_curve': equity_df,\n            'stats': stats\n        }\n    \n    def _calculate_stats(self, trades_df: pd.DataFrame, equity_df: pd.DataFrame) -> Dict:\n        """\n        計算績效指標\n        """\n        if trades_df.empty:\n            return {\n                'total_trades': 0,\n                'win_rate': 0,\n                'avg_profit': 0,\n                'avg_loss': 0,\n                'profit_factor': 0,\n                'max_drawdown': 0,\n                'final_balance': self.initial_capital,\n                'total_return': 0,\n                'return_pct': 0\n            }\n        \n        # 篩選平倉交易\n        closed_trades = trades_df[trades_df['type'].str.contains('CLOSE')]\n        \n        if closed_trades.empty:\n            return {\n                'total_trades': 0,\n                'win_rate': 0,\n                'avg_profit': 0,\n                'avg_loss': 0,\n                'profit_factor': 0,\n                'max_drawdown': 0,\n                'final_balance': trades_df.iloc[-1]['balance'],\n                'total_return': trades_df.iloc[-1]['balance'] - self.initial_capital,\n                'return_pct': (trades_df.iloc[-1]['balance'] / self.initial_capital - 1) * 100\n            }\n        \n        # 基本統計\n        total_trades = len(closed_trades)\n        winning_trades = closed_trades[closed_trades['pnl'] > 0]\n        losing_trades = closed_trades[closed_trades['pnl'] < 0]\n        \n        win_rate = len(winning_trades) / total_trades * 100 if total_trades > 0 else 0\n        \n        avg_profit = winning_trades['pnl'].mean() if len(winning_trades) > 0 else 0\n        avg_loss = losing_trades['pnl'].mean() if len(losing_trades) > 0 else 0\n        \n        total_profit = winning_trades['pnl'].sum() if len(winning_trades) > 0 else 0\n        total_loss = abs(losing_trades['pnl'].sum()) if len(losing_trades) > 0 else 0\n        profit_factor = total_profit / total_loss if total_loss > 0 else float('inf')\n        \n        # 最大回撒\n        equity_series = equity_df['equity']\n        running_max = equity_series.expanding().max()\n        drawdown = (equity_series - running_max) / running_max\n        max_drawdown = drawdown.min() * 100\n        \n        final_balance = trades_df.iloc[-1]['balance']\n        total_return = final_balance - self.initial_capital\n        return_pct = (final_balance / self.initial_capital - 1) * 100\n        \n        return {\n            'total_trades': total_trades,\n            'win_rate': win_rate,\n            'avg_profit': avg_profit,\n            'avg_loss': avg_loss,\n            'profit_factor': profit_factor,\n            'max_drawdown': max_drawdown,\n            'final_balance': final_balance,\n            'total_return': total_return,\n            'return_pct': return_pct\n        }\n