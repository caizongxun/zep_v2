"""\n改良版區間震盪策略 (Strategy C)\n\n核心邏輯:\n1. 確認盤整: ADX < 25\n2. 超賣進場: 價格觸及 BB 下軌 + RSI < 30 + 成交量萎縮\n3. 超買進場: 價格觸及 BB 上軌 + RSI > 70 + 成交量萎縮\n4. 出場: 價格回到 BB 中軌 或 ATR 止損\n"""\n\nimport pandas as pd\nimport numpy as np\nfrom typing import Dict, Literal\n\n\nclass RangeBoundStrategy:\n    def __init__(\n        self,\n        adx_threshold: float = 25,\n        rsi_oversold: float = 30,\n        rsi_overbought: float = 70,\n        volume_ma_period: int = 20,\n        volume_threshold: float = 0.8,  # Volume < 0.8x MA indicates contraction\n        use_atr_stops: bool = True,\n        atr_multiplier: float = 2.0,\n        fixed_stop_pct: float = 0.02,\n        target_rr: float = 2.0  # Risk-Reward Ratio\n    ):\n        self.adx_threshold = adx_threshold\n        self.rsi_oversold = rsi_oversold\n        self.rsi_overbought = rsi_overbought\n        self.volume_ma_period = volume_ma_period\n        self.volume_threshold = volume_threshold\n        self.use_atr_stops = use_atr_stops\n        self.atr_multiplier = atr_multiplier\n        self.fixed_stop_pct = fixed_stop_pct\n        self.target_rr = target_rr\n        \n    def add_indicators(self, df: pd.DataFrame) -> pd.DataFrame:\n        """\n        計算所需指標\n        """\n        df = df.copy()\n        \n        # ATR\n        high_low = df['high'] - df['low']\n        high_close = np.abs(df['high'] - df['close'].shift())\n        low_close = np.abs(df['low'] - df['close'].shift())\n        ranges = pd.concat([high_low, high_close, low_close], axis=1)\n        true_range = np.max(ranges, axis=1)\n        df['atr'] = true_range.rolling(14).mean()\n        \n        # Bollinger Bands (20, 2)\n        df['bb_mid'] = df['close'].rolling(20).mean()\n        bb_std = df['close'].rolling(20).std()\n        df['bb_upper'] = df['bb_mid'] + (2 * bb_std)\n        df['bb_lower'] = df['bb_mid'] - (2 * bb_std)\n        df['bb_width'] = (df['bb_upper'] - df['bb_lower']) / df['bb_mid']\n        \n        # RSI (14)\n        delta = df['close'].diff()\n        gain = (delta.where(delta > 0, 0)).rolling(14).mean()\n        loss = (-delta.where(delta < 0, 0)).rolling(14).mean()\n        rs = gain / loss\n        df['rsi'] = 100 - (100 / (1 + rs))\n        \n        # ADX (14)\n        plus_dm = df['high'].diff()\n        minus_dm = -df['low'].diff()\n        plus_dm[plus_dm < 0] = 0\n        minus_dm[minus_dm < 0] = 0\n        \n        tr_sum = true_range.rolling(14).sum()\n        plus_di = 100 * (plus_dm.rolling(14).sum() / tr_sum)\n        minus_di = 100 * (minus_dm.rolling(14).sum() / tr_sum)\n        \n        dx = (np.abs(plus_di - minus_di) / (plus_di + minus_di)) * 100\n        df['adx'] = dx.rolling(14).mean()\n        \n        # Volume MA\n        df['volume_ma'] = df['volume'].rolling(self.volume_ma_period).mean()\n        \n        return df\n    \n    def check_range_conditions(self, row: pd.Series) -> bool:\n        """\n        檢查是否處於盤整區間\n        """\n        # ADX < 25 確認盤整\n        if pd.isna(row['adx']) or row['adx'] >= self.adx_threshold:\n            return False\n        \n        # BB 寬度確認 (避免極端異常)\n        if pd.isna(row['bb_width']) or row['bb_width'] < 0.01:\n            return False\n            \n        return True\n    \n    def generate_signal(self, df: pd.DataFrame) -> Dict:\n        """\n        生成交易信號\n        \n        Returns:\n            {\n                'signal': 'buy' | 'sell' | 'hold',\n                'entry_price': float,\n                'stop_loss': float,\n                'take_profit': float,\n                'reason': str\n            }\n        """\n        if df.empty:\n            return {'signal': 'hold', 'entry_price': None, 'stop_loss': None, 'take_profit': None, 'reason': 'Empty data'}\n        \n        # 獲取最新一根K線\n        row = df.iloc[-1]\n        \n        # 基本檢查\n        if not self.check_range_conditions(row):\n            return {'signal': 'hold', 'entry_price': None, 'stop_loss': None, 'take_profit': None, 'reason': 'Not in range-bound market'}\n        \n        current_price = row['close']\n        atr = row['atr']\n        \n        # 成交量萎縮確認\n        volume_contracted = row['volume'] < (row['volume_ma'] * self.volume_threshold)\n        \n        # === 做多條件: 超賣反彈 ===\n        if (row['close'] <= row['bb_lower'] and  # 價格觸及BB下軌\n            row['rsi'] < self.rsi_oversold and    # RSI超賣\n            volume_contracted):                   # 成交量萎縮\n            \n            # 止損設定\n            if self.use_atr_stops:\n                stop_loss = current_price - (atr * self.atr_multiplier)\n            else:\n                stop_loss = current_price * (1 - self.fixed_stop_pct)\n            \n            # 止盈設定: 目標為BB中軌\n            take_profit = row['bb_mid']\n            \n            # 確保風報比合理\n            risk = current_price - stop_loss\n            reward = take_profit - current_price\n            if reward / risk < 1.0:  # 最低1:1\n                take_profit = current_price + (risk * self.target_rr)\n            \n            return {\n                'signal': 'buy',\n                'entry_price': current_price,\n                'stop_loss': stop_loss,\n                'take_profit': take_profit,\n                'reason': f'Oversold bounce: RSI={row[\"rsi\"]:.1f}, Price at BB lower, Volume contracted'\n            }\n        \n        # === 做空條件: 超買回落 ===\n        elif (row['close'] >= row['bb_upper'] and  # 價格觸及BB上軌\n              row['rsi'] > self.rsi_overbought and  # RSI超買\n              volume_contracted):                   # 成交量萎縮\n            \n            # 止損設定\n            if self.use_atr_stops:\n                stop_loss = current_price + (atr * self.atr_multiplier)\n            else:\n                stop_loss = current_price * (1 + self.fixed_stop_pct)\n            \n            # 止盈設定: 目標為BB中軌\n            take_profit = row['bb_mid']\n            \n            # 確保風報比合理\n            risk = stop_loss - current_price\n            reward = current_price - take_profit\n            if reward / risk < 1.0:\n                take_profit = current_price - (risk * self.target_rr)\n            \n            return {\n                'signal': 'sell',\n                'entry_price': current_price,\n                'stop_loss': stop_loss,\n                'take_profit': take_profit,\n                'reason': f'Overbought reversal: RSI={row[\"rsi\"]:.1f}, Price at BB upper, Volume contracted'\n            }\n        \n        return {'signal': 'hold', 'entry_price': None, 'stop_loss': None, 'take_profit': None, 'reason': 'Waiting for setup'}\n    \n    def check_exit(self, df: pd.DataFrame, position_type: Literal['long', 'short']) -> Dict:\n        """\n        檢查出場條件\n        \n        除了止損止盈外，還檢查是否回到BB中軌\n        """\n        if df.empty:\n            return {'exit': False, 'reason': ''}\n        \n        row = df.iloc[-1]\n        \n        # 價格回到BB中軌附近 (容忍度0.2%)\n        tolerance = 0.002\n        at_middle = abs(row['close'] - row['bb_mid']) / row['bb_mid'] < tolerance\n        \n        if at_middle:\n            return {'exit': True, 'reason': 'Price returned to BB mid'}\n        \n        return {'exit': False, 'reason': ''}\n